<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>React Technical Documentation Page</title>
        <!-- CSS Normalize -->
        <link href="Normalize.css" rel="stylesheet" type="text/css">
        <link href="styles.css" rel="stylesheet" type="text/css">
    </head>

    <body>
        <main id="main-doc">
            <!-- Navbar -->
            <nav id="navbar">
                <header class="logo-container">
                    <!-- width="786" height="480" -->
                    <video  autoplay muted loop poster="./Logo.png">
                        <source src="./React Logo.mp4" type="video/mp4">
                    </video>
                    <p class="header1">React</p>
                    <p class="header2">Documentation
                </header>
                <p><a class="nav-link" href="#hello_world">Hello World</a></p>
                <p><a class="nav-link" href="#introducing_jsx">Introducing JSX</a></p>
                <p><a class="nav-link" href="#rendering_elements">Rendering Elements</a></p>
                <p><a class="nav-link" href="#components_and_props">Components and Props</a></p>
                <p><a class="nav-link" href="#state_and_lifecycle">State and Lifecycle</a></p>
                <p><a class="nav-link" href="#handling_events">Handling Events</a></p>
                <p><a class="nav-link" href="#reference">Reference</a></p>
            </nav>
        
            <section id="hello_world" class="main-section">
                <header><h1>Hello World</h1></header>
                <p>The smallest React example looks like this:</p>
                <code>
                    const root = ReactDOM.createRoot(document.getElementById('root'));<br>
                    root.render(&lt;h1&gt;Hello, world!&lt;/h1&gt;);<br>
                </code>
                <p>It displays a heading saying “Hello, world!” on the page.</p>
                <hr>

                <h3>How to Read This Guide</h3>
                <p>
                    In this guide, we will examine the building blocks of React apps: elements and 
                    components. Once you master them, you can create complex apps from small reusable 
                    pieces.
                </p>
                <p class="next-para">
                    This is the first chapter in a step-by-step guide about main 
                    React concepts. You can find a list of all its chapters in the navigation sidebar.
                </p>
                <p class="next-para">
                    Every chapter in this guide builds on the knowledge introduced in earlier chapters. 
                    You can learn most of React by reading the “Main Concepts” guide chapters in the 
                    order they appear in the sidebar. For example, “Introducing JSX” is the next chapter 
                    after this one.
                </p>
                <hr>
                
                <h3>Knowledge Level Assumptions</h3>
                <p>
                    React is a JavaScript library, and so we’ll assume you have a basic understanding 
                    of the JavaScript language. If you don’t feel very confident, we recommend going 
                    through a 
                    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript"
                    target="_blank">
                    JavaScript tutorial</a> 
                    to check your knowledge level and enable you to follow along this guide without 
                    getting lost. It might take you between 30 minutes and an hour, but as a result 
                    you won’t have to feel like you’re learning both React and JavaScript at the same time.
                </p>
            </section>
            <hr class="rule-after-section">
            
            <section id="introducing_jsx" class="main-section">
                <header><h1>Introducing JSX</h1></header>
                <p>Consider this variable declaration:</p>
                <code>
                    const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;
                </code>
                <p>This funny tag syntax is neither a string nor HTML.</p>
                <p class="next-para">
                    It is called JSX, and it is a syntax extension to JavaScript. We recommend using 
                    it with React to describe what the UI should look like. JSX may remind you of a 
                    template language, but it comes with the full power of JavaScript.
                </p>
                <p class="next-para">
                    JSX produces React “elements”. We will explore rendering them to the DOM in the 
                    next section. Below, you can find the basics of JSX necessary to get you started.
                </p>
                <hr>

                <h3>Why JSX?</h3>
                <p>
                    React embraces the fact that rendering logic is inherently coupled with other UI 
                    logic: how events are handled, how the state changes over time, and how the data 
                    is prepared for display.
                </p>
                <p class="next-para">
                    Instead of artificially separating technologies by putting markup and logic in 
                    separate files, React separates concerns with loosely coupled units called 
                    “components” that contain both. We will come back to components in a further section.
                </p>
                <p class="next-para">
                    React doesn’t require using JSX, but most people find it helpful as a visual aid 
                    when working with UI inside the JavaScript code. It also allows React to show more 
                    useful error and warning messages.
                </p>
                <p class="next-para">
                    With that out of the way, let’s get started!
                </p>
                <hr>

                <h3>Embedding Expressions in JSX</h3>
                <p>
                    In the example below, we declare a variable called name and then use it inside 
                    JSX by wrapping it in curly braces:
                </p>
                <code>
                    const name = 'Josh Perez';<br>
                    const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;
                </code>
                <p class="next-para">
                    You can put any valid JavaScript expression inside the curly braces in JSX. For 
                    example, 2 + 2, user.firstName, or formatName(user) are all valid JavaScript 
                    expressions.
                </p>
                <p class="next-para">
                    In the example below, we embed the result of calling a JavaScript function, 
                    formatName(user), into an &lt;h1&gt; element.
                </p>
                <code>
                    function formatName(user) {<br>
                        &nbsp;&nbsp;return user.firstName + ' ' + user.lastName;<br>
                    }<br>
                    <br>                  
                    const user = {<br>
                        &nbsp;&nbsp;firstName: 'Harper',<br>
                        &nbsp;&nbsp;lastName: 'Perez'<br>
                    };<br>
                    <br>
                    const element = (<br>
                        &nbsp;&nbsp;&lt;h1&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;Hello, {formatName(user)}!<br>
                        &nbsp;&nbsp;&lt;/h1&gt;<br>
                    );
                </code>
                <p class="next-para">
                    We split JSX over multiple lines for readability. While it isn’t required, when 
                    doing this, we also recommend wrapping it in parentheses to avoid the pitfalls 
                    of automatic semicolon insertion.
                </p>
                <hr>
                
                <h3>JSX is an Expression Too</h3>
                <p>
                    After compilation, JSX expressions become regular JavaScript function calls and 
                    evaluate to JavaScript objects.
                </p>
                <p class="next-para">
                    This means that you can use JSX inside of if statements and for loops, assign it 
                    to variables, accept it as arguments, and return it from functions:
                </p>
                <code>
                    function getGreeting(user) {<br>
                        &nbsp;&nbsp;if (user) {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return &lt;h1&gt;Hello, {formatName(user)}!&lt;/h1&gt;;<br>
                        &nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;<br>
                    }
                </code>
                <hr>

                <h3>Specifying Attributes with JSX</h3>
                <p>You may use quotes to specify string literals as attributes:</p>
                <code>
                    const element = &lt;a href="https://www.reactjs.org"&gt; link &lt;/a&gt;;
                </code>
                <p>
                    You may also use curly braces to embed a JavaScript expression in an attribute:
                </p>
                <code>
                    const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;
                </code>
                <p>
                    Don’t put quotes around curly braces when embedding a JavaScript expression in 
                    an attribute. You should either use quotes (for string values) or curly braces 
                    (for expressions), but not both in the same attribute.
                </p>
                <hr>

                <h3>Specifying Children with JSX</h3>
                <p>If a tag is empty, you may close it immediately with />, like XML:</p>
                <code>
                    const element = &lt;img src={user.avatarUrl} /&gt;;
                </code>
                <p>JSX tags may contain children:</p>
                <code>
                    const element = (<br>
                        &nbsp;&nbsp;&lt;div&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hello!&lt;/h1&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&gt;Good to see you here&lt;/h2&gt;<br>
                        &nbsp;&nbsp;&lt;/div&gt;<br>
                    );
                </code>
                <hr>

                <h3>JSX Prevents Injection Attacks</h3>
                <p>It is safe to embed user input in JSX:</p>
                <code>
                    const title = response.potentiallyMaliciousInput;<br>
                    // This is safe:<br>
                    const element = &lt;h1&gt;{title}&lt;h1&gt;;<br>
                </code>
                <p>
                    By default, React DOM escapes any values embedded in JSX before rendering them. 
                    Thus it ensures that you can never inject anything that’s not explicitly written 
                    in your application. Everything is converted to a string before being rendered. 
                    This helps prevent XSS (cross-site-scripting) attacks.
                </p>
                <hr>

                <h3>JSX Represents Objects</h3>
                <p>Babel compiles JSX down to <code class="inline-code">React.createElement()</code> calls.</p>
                <p class="next-para">These two examples are identical:</p>
                <code>
                    const element = (<br>
                        &nbsp;&nbsp;&lt;h1 className="greeting"&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;Hello, world!<br>
                        &nbsp;&nbsp;&lt;/h1&gt;<br>
                    );
                </code>
                <br>
                <code>
                    const element = React.createElement(<br>
                        &nbsp;&nbsp;'h1',<br>
                        &nbsp;&nbsp;{className: 'greeting'},<br>
                        &nbsp;&nbsp;'Hello, world!'<br>
                    );
                </code>
                <p>
                    <code class="inline-code">React.createElement()</code> performs a few checks to help you write bug-free code but 
                    essentially it creates an object like this:
                </p>
                <code>
                    // Note: this structure is simplified<br>
                    const element = {<br>
                        &nbsp;&nbsp;type: 'h1',<br>
                        &nbsp;&nbsp;props: {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;className: 'greeting',<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;children: 'Hello, world!'<br>
                        &nbsp;&nbsp;}<br>
                    };
                </code>
                <p>
                    These objects are called “React elements”. You can think of them as descriptions 
                    of what you want to see on the screen. React reads these objects and uses them 
                    to construct the DOM and keep it up to date.
                </p>
                <p class="next-para">
                    We will explore rendering React elements to the DOM in the next section.
                </p>
            </section>
            <hr class="rule-after-section">

            <section id="rendering_elements" class="main-section">
                <header><h1>Rendering Elements</h1></header>
                <p>Elements are the smallest building blocks of React apps.</p>
                <p class="next-para">
                    An element describes what you want to see on the screen:
                </p>
                <code>
                    const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
                </code>
                <p>
                    Unlike browser DOM elements, React elements are plain objects, and are cheap to 
                    create. React DOM takes care of updating the DOM to match the React elements.
                </p>
                <hr>
                
                <h3>Rendering an Element into the DOM</h3>
                <p>Let’s say there is a &lt;div&gt; somewhere in your HTML file:</p>
                <code>
                    &lt;div id="root"&gt;&lt;/div&gt;
                </code>
                <p>
                    We call this a “root” DOM node because everything inside it will be managed by 
                    React DOM.
                </p>
                <p class="next-para">
                    Applications built with just React usually have a single root DOM node. If you are 
                    integrating React into an existing app, you may have as many isolated root DOM 
                    nodes as you like.
                </p>
                <p class="next-para">
                    To render a React element, first pass the DOM element to 
                    <code class="inline-code">ReactDOM.createRoot()</code>, 
                    then pass the React element to 
                    <code class="inline-code">root.render()</code>:
                </p>
                <code>
                    const root = ReactDOM.createRoot(<br>
                        &nbsp;&nbsp;document.getElementById('root')<br>
                    );<br>
                    const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;<br>
                    root.render(element);
                </code>
                <p>It displays “Hello, world” on the page.</p>
                <hr>
                
                <h3>Updating the Rendered Element</h3>
                <p>
                    React elements are immutable. Once you create an element, you can’t change its 
                    children or attributes. An element is like a single frame in a movie: it 
                    represents the UI at a certain point in time.
                </p>
                <p class="next-para">
                    With our knowledge so far, the only way to update the UI is to create a new 
                    element, and pass it to <code class="inline-code">root.render()</code>.
                </p>
                <p class="next-para">Consider this ticking clock example:</p>
                <code>
                    const root = ReactDOM.createRoot(<br>
                      document.getElementById('root')<br>
                    );<br>
                    <br>
                    function tick() {<br>
                        &nbsp;&nbsp;const element = (<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hello, world&lt;/h1&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                        &nbsp;&nbsp;);<br>
                        &nbsp;&nbsp;root.render(element);}<br>
                    }<br>
                    <br>
                    setInterval(tick, 1000);
                </code>
                <p>
                    It calls <code class="inline-code">root.render()</code> every second from a 
                    <code class="inline-code">setInterval()</code> callback.
                </p>
                <hr>
                
                <h3>React Only Updates What’s Necessary</h3>
                <p>
                    React DOM compares the element and its children to the previous one, and only 
                    applies the DOM updates necessary to bring the DOM to the desired state.
                </p>
                <p class="next-para">
                    You can verify by inspecting the last example with the browser tools:
                </p>
                <img src="https://reactjs.org/c158617ed7cc0eac8f58330e49e48224/granular-dom-updates.gif"
                alt="React granular DOM updates">
                <p class="next-para">
                    Even though we create an element describing the whole UI tree on every tick, only 
                    the text node whose contents have changed gets updated by React DOM.
                </p>
                <p class="next-para">
                    In our experience, thinking about how the UI should look at any given moment, 
                    rather than how to change it over time, eliminates a whole class of bugs.
                </p>
            </section>
            <hr class="rule-after-section">

            <section id="components_and_props" class="main-section">
                <header><h1>Components and Props</h1></header>
                <p>
                    Components let you split the UI into independent, reusable pieces, and think 
                    about each piece in isolation. This page provides an introduction to the idea 
                    of components.
                </p>
                <p class="next-para">
                    Conceptually, components are like JavaScript functions. They accept arbitrary 
                    inputs (called “props”) and return React elements describing what should appear 
                    on the screen.
                </p>
                <hr>

                <h3>Function and Class Components</h3>
                <p>The simplest way to define a component is to write a JavaScript function:</p>
                <code>
                    function Welcome(props) {<br>
                        &nbsp;&nbsp;return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;<br>
                    }
                </code>
                <p>
                    This function is a valid React component because it accepts a single “props” 
                    (which stands for properties) object argument with data and returns a React 
                    element. We call such components “function components” because they are 
                    literally JavaScript functions.
                </p>
                <p class="next-para">
                    You can also use an ES6 class to define a component:
                </p>
                <code>
                    class Welcome extends React.Component {<br>
                        &nbsp;&nbsp;render() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;<br>
                        &nbsp;&nbsp;}<br>
                    }
                </code>
                <p>
                    The above two components are equivalent from React’s point of view.
                </p>
                <p class="next-para">
                    Function and Class components both have some additional features that we will 
                    discuss in the next sections.
                </p>
                <hr>

                <h3>Rendering a Component</h3>
                <p>Previously, we only encountered React elements that represent DOM tags:</p>
                <code>
                    const element = &lt;div /&gt;;
                </code>
                <p>However, elements can also represent user-defined components:</p>
                <code>
                    const element = &lt;Welcome name="Sara" /&gt;;
                </code>
                <p>
                    When React sees an element representing a user-defined component, it passes JSX 
                    attributes and children to this component as a single object. We call this 
                    object “props”.
                </p>
                <p class="next-para">
                    For example, this code renders “Hello, Sara” on the page:
                </p>
                <code>
                    function Welcome(props) {<br>
                        &nbsp;&nbsp;return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;<br>
                    }<br>
                    <br>
                    const root = ReactDOM.createRoot(document.getElementById('root'));<br>
                    const element = &lt;Welcome name="Sara" /&gt;;<br>
                    root.render(element);
                </code>
                <ol>
                    Let’s recap what happens in this example:
                    <li>
                        We call <code class="inline-code">root.render()</code> with the 
                        <code class="inline-code">&lt;Welcome name="Sara" /&gt;</code> element.
                    </li>
                    <li>
                        React calls the Welcome component with <code class="inline-code">{name: 'Sara'}</code> as 
                        the props.
                    </li>
                    <li>
                        Our Welcome component returns a 
                        <code class="inline-code">&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code> element as the result.
                    </li>
                    <li>
                        React DOM efficiently updates the DOM to match 
                        <code class="inline-code">&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>.
                    </li>
                </ol>
                <hr>

                <h3>Composing Components</h3>
                <p>
                    Components can refer to other components in their output. This lets us use the same component 
                    abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, 
                    all those are commonly expressed as components.
                </p>
                <p class="next-para">
                    For example, we can create an <code class="inline-code">App</code> component that renders 
                    <code class="inline-code">Welcome</code> many times:
                </p>
                <code>
                    function Welcome(props) {<br>
                        &nbsp;&nbsp;return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;<br>
                    }<br>
                    <br>
                    function App() {<br>
                        &nbsp;&nbsp;return (<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Welcome name="Sara" /><br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Welcome name="Cahal" /><br>      
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<Welcome name="Edite" /><br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                        &nbsp;&nbsp;);<br>
                    }
                </code>
                <p>
                    Typically, new React apps have a single <code class="inline-code">App</code> component at the 
                    very top. However, if you integrate React into an existing app, you might start bottom-up with 
                    a small component like <code class="inline-code">Button</code> and gradually work your way to 
                    the top of the view hierarchy.
                </p>
                <hr>

                <h3>Extracting Components</h3>
                <p>Don’t be afraid to split components into smaller components.</p>
                <p class="next-para">
                    For example, consider this <code class="inline-code">Comment</code> component:
                </p>
                <code>
                    function Comment(props) {<br>
                        &nbsp;&nbsp;return (<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="Comment"&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="UserInfo"&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img className="Avatar"<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src={props.author.avatarUrl}<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alt={props.author.name}<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="UserInfo-name"&gt;<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{props.author.name}<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="Comment-text"&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{props.text}<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="Comment-date"&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{formatDate(props.date)}<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                        &nbsp;&nbsp;);<br>
                    }
                </code>
                <p>
                    It accepts <code class="inline-code">author</code> (an object), 
                    <code class="inline-code">text</code> (a string), and 
                    <code class="inline-code">date</code> (a date) as props, and describes a comment on a social 
                    media website.
                </p>
                <p class="next-para">
                    This component can be tricky to change because of all the nesting, and it is also hard to reuse 
                    individual parts of it. Let’s extract a few components from it.
                </p>
                <p class="next-para">
                    First, we will extract <code class="inline-code">Avatar</code>:
                </p>
                <code>
                    function Avatar(props) {<br>
                        &nbsp;&nbsp;return (<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;img className="Avatar" <br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;src={props.user.avatarUrl} <br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alt={props.user.name} <br>  
                            &nbsp;&nbsp;&nbsp;&nbsp;/&gt;<br>
                        &nbsp;&nbsp;);<br>
                    }
                </code>
                <p>
                    The <code class="inline-code">Avatar</code> doesn’t need to know that it is being rendered inside 
                    a <code class="inline-code">Comment</code>. This is why we have given its prop a more generic 
                    name: <code class="inline-code">user</code> rather than <code class="inline-code">author</code>.
                </p>
                <p class="next-para">
                    We recommend naming props from the component’s own point of view rather than the context in which 
                    it is being used.
                </p>
                <p class="next-para">
                    We can now simplify <code class="inline-code">Comment</code> a tiny bit:
                </p>
                <code>
                    function Comment(props) {<br>
                        &nbsp;&nbsp;return (<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="Comment"&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="UserInfo"&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Avatar user={props.author} /&gt;<br>    
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="UserInfo-name"&gt;<br>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{props.author.name}<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="Comment-text"&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{props.text}<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="Comment-date"&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{formatDate(props.date)}<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                        &nbsp;&nbsp;);<br>
                    }
                </code>
                <p>
                    Next, we will extract a <code class="inline-code">UserInfo</code> component that renders an <code class="inline-code">Avatar</code> next to the user’s name:
                </p>
                <code>
                    function UserInfo(props) {<br>
                        &nbsp;&nbsp;return (<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="UserInfo"&gt;<br>      
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Avatar user={props.user} /&gt;<br>      
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="UserInfo-name"&gt;<br>        
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{props.user.name}<br>      
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>    
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>  
                        &nbsp;&nbsp;);<br>
                    }
                </code>
                <p>This lets us simplify <code class="inline-code">Comment</code> even further:</p>
                <code>
                    function Comment(props) {<br>
                        &nbsp;&nbsp;return (<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="Comment"&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;UserInfo user={props.author} /&gt;<br>      
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="Comment-text"&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{props.text}<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div className="Comment-date"&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{formatDate(props.date)}<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                        &nbsp;&nbsp;);<br>
                    }
                </code>
                <p>
                    Extracting components might seem like grunt work at first, but having a palette of reusable 
                    components pays off in larger apps. A good rule of thumb is that if a part of your UI is used 
                    several times (<code class="inline-code">Button, Panel, Avatar</code>), or is complex enough 
                    on its own (<code class="inline-code">App, FeedStory, Comment</code>), it is a good candidate 
                    to be extracted to a separate component.
                </p>
                <hr>

                <h3>Props are Read-Only</h3>
                <p>
                    Whether you declare a component as a function or a class, it must never modify its own props. 
                    Consider this <code class="inline-code">sum</code> function:
                </p>
                <code>
                    function sum(a, b) {<br>
                        &nbsp;&nbsp;return a + b;<br>
                    }
                </code>
                <p>
                    Such functions are called “pure” because they do not attempt to change their inputs, and always 
                    return the same result for the same inputs.
                </p>
                <p class="next-para">
                    In contrast, this function is impure because it changes its own input:
                </p>
                <code>
                    function withdraw(account, amount) {<br>
                        &nbsp;&nbsp;account.total -= amount;<br>
                    }
                </code>
                <p>React is pretty flexible but it has a single strict rule:</p>
                <p>
                    <strong>All React components must act like pure functions with respect to their props.</strong>
                </p>
                <p>
                    Of course, application UIs are dynamic and change over time. In the next section, we will 
                    introduce a new concept of “state”. State allows React components to change their output over 
                    time in response to user actions, network responses, and anything else, without violating this 
                    rule.
                </p>
            </section>
            <hr class="rule-after-section">
            
            <section id="state_and_lifecycle" class="main-section">
                <header><h1>State and Lifecycle</h1></header>
                <p>
                    Consider the ticking clock example from one of the previous sections. In Rendering Elements, we 
                    have only learned one way to update the UI. We call <code class="inline-code">root.render()</code> 
                    to change the rendered output:
                </p>
                <code>
                    const root =<br> 
                    ReactDOM.createRoot(document.getElementById('root'));<br>
                    <br>
                    function tick() {<br>
                        &nbsp;&nbsp;const element = (<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hello, world!&lt;/h1&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                        &nbsp;&nbsp;);<br>
                        &nbsp;&nbsp;root.render(element);}<br>
                    <br>
                    setInterval(tick, 1000);
                </code>
                <p>
                    In this section, we will learn how to make the <code class="inline-code">Clock</code> component 
                    truly reusable and encapsulated. It will set up its own timer and update itself every second.
                </p>
                <p>
                    We can start by encapsulating how the clock looks:
                </p>
                <code>
                    const root = <br>
                    ReactDOM.createRoot(document.getElementById('root'));<br>
                    <br>
                    function Clock(props) {<br>
                        &nbsp;&nbsp;return (<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;<br>      
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hello, world!&lt;/h1&gt;<br>      
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;<br>    
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>  
                        &nbsp;&nbsp;);<br>
                    }<br>
                    <br>    
                    function tick() {<br>
                        &nbsp;&nbsp;root.render(&lt;Clock date={new Date()} /&gt;);<br>
                    }<br>
                    <br>    
                    setInterval(tick, 1000);
                </code>
                <p>
                    However, it misses a crucial requirement: the fact that the <code class="inline-code">Clock</code> 
                    sets up a timer and updates the UI every second should be an implementation detail of the 
                    <code class="inline-code">Clock</code>.
                </p>
                <p>
                    Ideally we want to write this once and have the <code class="inline-code">Clock</code> 
                    update itself:
                </p>
                <code>
                    root.render(&lt;Clock /&gt;);
                </code>
                <p>
                    To implement this, we need to add “state” to the <code class="inline-code">Clock</code> component.
                </p>
                <p>
                    State is similar to props, but it is private and fully controlled by the component.
                </p>
                <hr>

                <h3>Converting a Function to a Class</h3>
                <p>
                    You can convert a function component like <code class="inline-code">Clock</code> to a class 
                    in five steps:
                </p>
                <ol>
                    <li>
                        Create an ES6 class, with the same name, that extends <code class="inline-code">React.Component</code>.
                    </li>
                    <li>
                        Add a single empty method to it called <code class="inline-code">render()</code>.
                    </li>
                    <li>
                        Move the body of the function into the <code class="inline-code">render()</code> method.
                    </li>
                    <li>
                        Replace <code class="inline-code">props</code> with <code class="inline-code">this.props</code> in 
                        the <code class="inline-code">render()</code> body.
                    </li>
                    <li>
                        Delete the remaining empty function declaration.
                    </li>
                </ol>
                <code>
                    class Clock extends React.Component {<br>
                        &nbsp;&nbsp;render() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return (<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hello, world!&lt;/h1&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;);<br>
                        &nbsp;&nbsp;}<br>
                    }
                </code>
                <p>
                    <code class="inline-code">Clock</code> is now defined as a class rather than a function.
                </p>
                <p>
                    The <code class="inline-code">render</code> method will be called each time an update happens, 
                    but as long as we render <code class="inline-code">&lt;Clock /&gt;</code> into the same DOM node, 
                    only a single instance of the <code class="inline-code">Clock</code> class will be used. This 
                    lets us use additional features such as local state and lifecycle methods.
                </p>
                <hr>

                <h3>Adding Local State to a Class </h3>
                <p>
                    We will move the <code class="inline-code">date</code> from props to state in three steps:
                </p>
                <p>
                    1. Replace <code class="inline-code">this.props.date</code> with 
                    <code class="inline-code">this.state.date</code> in the <code class="inline-code">render()</code> 
                    method:
                </p>
                <code>
                    class Clock extends React.Component {<br>
                        &nbsp;&nbsp;render() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return (<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hello, world!&lt;/h1&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;);<br>
                        &nbsp;&nbsp;}<br>
                    }
                </code>
                <p>
                    2. Add a class constructor that assigns the initial <code class="inline-code">this.state</code>:
                </p>
                <code>
                    class Clock extends React.Component {<br>
                        &nbsp;&nbsp;constructor(props) {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;super(props);<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;this.state = {date: new Date()};<br>
                        &nbsp;&nbsp;}<br>
                    <br>
                        &nbsp;&nbsp;render() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return (<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hello, world!&lt;/h1&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;);<br>
                        &nbsp;&nbsp;}<br>
                    }
                </code>
                <p>
                    Note how we pass <code class="inline-code">props</code> to the base constructor:
                </p>
                <code>
                    constructor(props) {<br>
                        &nbsp;&nbsp;super(props);<br>    
                        &nbsp;&nbsp;this.state = {date: new Date()};<br>
                    }
                </code>
                <p>
                    Class components should always call the base constructor with <code class="inline-code">props</code>.
                </p>
                <p>
                    3. Remove the date prop from the <code class="inline-code">&lt;Clock /&gt;</code> element:
                </p>
                <code>
                    root.render(&lt;Clock /&gt;);
                </code>
                <p>
                    We will later add the timer code back to the component itself.
                </p>
                <p>The result looks like this:</p>
                <code>
                    class Clock extends React.Component {<br>
                        &nbsp;&nbsp;constructor(props) {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;super(props);<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;this.state = {date: new Date()};<br>
                        &nbsp;&nbsp;}<br>
                    <br>
                        &nbsp;&nbsp;render() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return (<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hello, world!&lt;/h1&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;);<br>
                        &nbsp;&nbsp;}<br>
                    }<br>
                    <br>
                    const root = <br>
                    ReactDOM.createRoot(document.getElementById('root'));<br>
                    root.render(&lt;Clock /&gt;);
                </code>
                <p>
                    Next, we’ll make the <code class="inline-code">Clock</code> set up its own timer and update 
                    itself every second.
                </p>
                <hr>

                <h3>Adding Lifecycle Methods to a Class</h3>
                <p>
                    In applications with many components, it’s very important to free up resources taken by the 
                    components when they are destroyed.
                </p>
                <p>
                    We want to set up a timer whenever the <code class="inline-code">Clock</code> is rendered to 
                    the DOM for the first time. This is called “mounting” in React.
                </p>
                <p>
                    We also want to clear that timer whenever the DOM produced by the 
                    <code class="inline-code">Clock</code> is removed. This is called “unmounting” in React.
                </p>
                <p>
                    We can declare special methods on the component class to run some code when a component 
                    mounts and unmounts:
                </p>
                <code>
                    class Clock extends React.Component {<br>
                        &nbsp;&nbsp;constructor(props) {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;super(props);<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;this.state = {date: new Date()};<br>
                        &nbsp;&nbsp;}<br>
                    <br>
                        &nbsp;&nbsp;componentDidMount() {<br>
                        &nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;componentWillUnmount() {<br>
                        &nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;render() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return (<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hello, world!&lt;/h1&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;);<br>
                        &nbsp;&nbsp;}<br>
                    }
                </code>
                <p>These methods are called “lifecycle methods”.</p>
                <p>
                    The <code class="inline-code">componentDidMount()</code> method runs after the component output 
                    has been rendered to the DOM. This is a good place to set up a timer:
                </p>
                <code>
                    componentDidMount() {<br>
                        &nbsp;&nbsp;this.timerID = setInterval(<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;() => this.tick(),<br> 
                            &nbsp;&nbsp;&nbsp;&nbsp;1000<br>
                        &nbsp;&nbsp;);<br>
                    }
                </code>
                <p>
                    Note how we save the timer ID right on <code class="inline-code">this</code> 
                    (<code class="inline-code">this.timerID</code>).
                </p>
                <p>
                    While <code class="inline-code">this.props</code> is set up by React itself and 
                    <code class="inline-code">this.state</code> has a special meaning, you are free to add additional 
                    fields to the class manually if you need to store something that doesn’t participate in the data 
                    flow (like a timer ID).
                </p>
                <p>
                    We will tear down the timer in the <code class="inline-code">componentWillUnmount()</code> 
                    lifecycle method:
                </p>
                <code>
                    componentWillUnmount() {<br>
                        &nbsp;&nbsp;clearInterval(this.timerID);<br>
                    }
                </code>
                <p>
                    Finally, we will implement a method called <code class="inline-code">tick()</code> that the 
                    <code class="inline-code">Clock</code> component will run every second.
                </p>
                <p>
                    It will use <code class="inline-code">this.setState()</code> to schedule updates to the 
                    component local state:
                </p>
                <code>
                    class Clock extends React.Component {<br>
                        &nbsp;&nbsp;constructor(props) {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;super(props);<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;this.state = {date: new Date()};<br>
                        &nbsp;&nbsp;}<br>
                    <br>
                        &nbsp;&nbsp;componentDidMount() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;this.timerID = setInterval(<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;() => this.tick(),<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1000<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;);<br>
                        &nbsp;&nbsp;}<br>
                    <br>
                        &nbsp;&nbsp;componentWillUnmount() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;clearInterval(this.timerID);<br>
                        &nbsp;&nbsp;}<br>
                    <br>
                        &nbsp;&nbsp;tick() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;this.setState({<br> 
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;date: new Date()<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;});<br>
                        &nbsp;&nbsp;}<br>
                    <br>
                        &nbsp;&nbsp;render() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return (<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hello, world!&lt;/h1&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;);<br>
                        &nbsp;&nbsp;}<br>
                    }<br>
                    <br>
                    const root = ReactDOM.createRoot(document.getElementById('root'));<br>
                    root.render(&lt;Clock /&gt;);
                </code>
                <p>Now the clock ticks every second.</p>
                <p>Let’s quickly recap what’s going on and the order in which the methods are called:</p>
                <ol>
                    <li>
                        When <code class="inline-code">&lt;Clock /&gt;</code> is passed to 
                        <code class="inline-code">root.render()</code>, React calls the constructor of the 
                        <code class="inline-code">Clock</code> component. Since <code class="inline-code">Clock</code> 
                        needs to display the current time, it initializes <code class="inline-code">this.state</code> 
                        with an object including the current time. We will later update this state.
                    </li>
                    <li>
                        React then calls the <code class="inline-code">Clock</code> component’s 
                        <code class="inline-code">render()</code> method. This is how React learns what should be 
                        displayed on the screen. React then updates the DOM to match the 
                        <code class="inline-code">Clock</code>’s render output.
                    </li>
                    <li>
                        When the <code class="inline-code">Clock</code> output is inserted in the DOM, React calls the 
                        <code class="inline-code">componentDidMount()</code> lifecycle method. Inside it, the 
                        <code class="inline-code">Clock</code> component asks the browser to set up a timer to call 
                        the component’s <code class="inline-code">tick()</code> method once a second.
                    </li>
                    <li>
                        Every second the browser calls the <code class="inline-code">tick()</code> method. Inside it, 
                        the <code class="inline-code">Clock</code> component schedules a UI update by calling 
                        <code class="inline-code">setState()</code> with an object containing the current time. Thanks 
                        to the <code class="inline-code">setState()</code> call, React knows the state has changed, 
                        and calls the <code class="inline-code">render()</code> method again to learn what should be 
                        on the screen. This time, <code class="inline-code">this.state.date</code> in the 
                        <code class="inline-code">render()</code> method will be different, and so the render output 
                        will include the updated time. React updates the DOM accordingly.
                    </li>
                    <li>
                        If the <code class="inline-code">Clock</code> component is ever removed from the DOM, React 
                        calls the <code class="inline-code">componentWillUnmount()</code> lifecycle method so the 
                        timer is stopped.
                    </li>
                </ol>
                <hr>

                <h3>Using State Correctly </h3>
                <p>
                    There are three things you should know about <code class="inline-code">setState()</code>.
                </p>
                <h4>Do Not Modify State Directly</h4>
                <p>For example, this will not re-render a component:</p>
                <code>
                    // Wrong<br>
                    this.state.comment = 'Hello';
                </code>
                <p>Instead, use <code class="inline-code">setState()</code>:</p>
                <code>
                    // Correct<br>
                    this.setState({comment: 'Hello'});
                </code>
                <p>
                    The only place where you can assign <code class="inline-code">this.state</code> is the constructor.
                </p>

                <h4>State Updates May Be Asynchronous </h4>

                <p>
                    React may batch multiple <code class="inline-code">setState()</code> calls into a single 
                    update for performance.
                </p>
                <p>
                    Because <code class="inline-code">this.props</code> and <code class="inline-code">this.state</code> 
                    may be updated asynchronously, you should not rely on their values for calculating the next state.
                </p>
                <p>For example, this code may fail to update the counter:</p>
                <code>
                    // Wrong<br>
                    this.setState({<br>
                        &nbsp;&nbsp;counter: this.state.counter + this.props.increment,<br>
                    });
                </code>
                <p>
                    To fix it, use a second form of <code class="inline-code">setState()</code> that accepts a 
                    function rather than an object. That function will receive the previous state as the first 
                    argument, and the props at the time the update is applied as the second argument:
                </p>
                <code>
                    // Correct<br>
                    this.setState((state, props) => ({<br>
                        &nbsp;&nbsp;counter: state.counter + props.increment<br>
                    }));
                </code>
                <p>
                    We used an arrow function above, but it also works with regular functions:
                </p>
                <code>
                    // Correct<br>
                    this.setState(function(state, props) {<br>
                        &nbsp;&nbsp;return {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;counter: state.counter + props.increment<br>
                        &nbsp;&nbsp;};<br>
                    });
                </code>

                <h4>State Updates are Merged</h4>

                <p>
                    When you call <code class="inline-code">setState()</code>, React merges the object you provide 
                    into the current state.
                </p>
                <p>For example, your state may contain several independent variables:</p>
                <code>
                    constructor(props) {<br>
                        &nbsp;&nbsp;super(props);<br>
                        &nbsp;&nbsp;this.state = {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;posts: [],<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;comments: []<br>  
                        &nbsp;&nbsp;};<br>
                    }
                </code>
                <p>
                    Then you can update them independently with separate <code class="inline-code">setState()</code> 
                    calls:
                </p>
                <code>
                    componentDidMount() {<br>
                        &nbsp;&nbsp;fetchPosts().then(response => {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;this.setState({<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;posts: response.posts<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;});<br>
                        &nbsp;&nbsp;});<br>
                    <br>
                        &nbsp;&nbsp;fetchComments().then(response => {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;this.setState({<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;comments: response.comments<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;});<br>
                        &nbsp;&nbsp;});<br>
                    }
                </code>
                <p>
                    The merging is shallow, so <code class="inline-code">this.setState({comments})</code> leaves 
                    <code class="inline-code">this.state.posts</code> intact, but completely replaces 
                    <code class="inline-code">this.state.comments</code>.
                </p>
                <hr>

                <h3>The Data Flows Down</h3>
                <p>
                    Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn’t care 
                    whether it is defined as a function or a class.
                </p>
                <p>
                    This is why state is often called local or encapsulated. It is not accessible to any component other than the one that 
                    owns and sets it.
                </p>
                <p>A component may choose to pass its state down as props to its child components:</p>
                <code>
                    &lt;FormattedDate date={this.state.date} /&gt;
                </code>
                <p>
                    The <code class="inline-code">FormattedDate</code> component would receive the <code class="inline-code">date</code> 
                    in its props and wouldn’t know whether it came from the <code class="inline-code">Clock’s</code> state, from the 
                    <code class="inline-code">Clock’s</code> props, or was typed by hand:
                </p>
                <code>
                    function FormattedDate(props) {<br>
                        &nbsp;&nbsp;return &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;;<br>
                    }
                </code>
                <p>
                    This is commonly called a “top-down” or “unidirectional” data flow. Any state is always owned by some specific 
                    component, and any data or UI derived from that state can only affect components “below” them in the tree.
                </p>
                <p>
                    If you imagine a component tree as a waterfall of props, each component’s state is like an additional water source 
                    that joins it at an arbitrary point but also flows down.
                </p>
                <p>
                    To show that all components are truly isolated, we can create an <code class="inline-code">App</code> component 
                    that renders three <code class="inline-code">&lt;Clock&gt;</code>s:
                </p>
                <code>
                    function App() {<br>
                        &nbsp;&nbsp;return (<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Clock /&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Clock /&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Clock /&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br>
                        &nbsp;&nbsp;);<br>
                    }
                </code>
                <p>
                    Each <code class="inline-code">Clock</code> sets up its own timer and updates independently.
                </p>
                <p>
                    In React apps, whether a component is stateful or stateless is considered an implementation detail of the component 
                    that may change over time. You can use stateless components inside stateful components, and vice versa.
                </p>
            </section>
            <hr class="rule-after-section">

            <section id="handling_events" class="main-section">
                <header><h1>Handling Events</h1></header>
                <p>
                    Handling events with React elements is very similar to handling events on DOM elements. There are some syntax 
                    differences:
                </p>
                <ul>
                    <li>React events are named using camelCase, rather than lowercase.</li>
                    <li>With JSX you pass a function as the event handler, rather than a string.</li>
                </ul>
                <p>For example, the HTML:</p>
                <code>
                    &lt;button onclick="activateLasers()"&gt;<br>
                        &nbsp;&nbsp;Activate Lasers<br>
                    &lt;/button&gt;
                </code>
                <p>is slightly different in React:</p>
                <code>
                    &lt;button onClick={activateLasers}&gt;<br> 
                        &nbsp;&nbsp;Activate Lasers<br>
                    &lt;/button&gt;
                </code>
                <p>
                    Another difference is that you cannot return <code class="inline-code">false</code> to prevent default behavior in 
                    React. You must call <code class="inline-code">preventDefault</code> explicitly. For example, with plain HTML, to 
                    prevent the default form behavior of submitting, you can write:
                </p>
                <code>
                    &lt;form onsubmit="console.log('You clicked submit.'); return false"&gt;<br>
                        &nbsp;&nbsp;&lt;button type="submit"&gt;Submit&lt;/button&gt;<br>
                    &lt;/form&gt;
                </code>
                <p>In React, this could instead be:</p>
                <code>
                    function Form() {<br>
                        &nbsp;&nbsp;function handleSubmit(e) {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;e.preventDefault();<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;console.log('You clicked submit.');<br>
                        &nbsp;&nbsp;}<br>
                    <br>
                        &nbsp;&nbsp;return (<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;form onSubmit={handleSubmit}&gt;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button type="submit"&gt;Submit&lt;/button&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;<br>
                        &nbsp;&nbsp;);<br>
                    }
                </code>
                <p>
                    Here, <code class="inline-code">e</code> is a synthetic event. React defines these synthetic events according to the 
                    W3C spec, so you don’t need to worry about cross-browser compatibility. React events do not work exactly the same as 
                    native events. See the <code class="inline-code">SyntheticEvent</code> reference guide to learn more.
                </p>
                <p>
                    When using React, you generally don’t need to call <code class="inline-code">addEventListener</code> to add listeners 
                    to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.
                </p>
                <p>
                    When you define a component using an ES6 class, a common pattern is for an event handler to be a method on the class. 
                    For example, this <code class="inline-code">Toggle</code> component renders a button that lets the user toggle 
                    between “ON” and “OFF” states:
                </p>
                <code>
                    class Toggle extends React.Component {<br>
                        &nbsp;&nbsp;constructor(props) {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;super(props);<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;this.state = {isToggleOn: true};<br>
                    <br>
                            &nbsp;&nbsp;&nbsp;&nbsp;// This binding is necessary to make `this` work in the callback<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;this.handleClick = this.handleClick.bind(this);<br>
                        &nbsp;&nbsp;}<br>
                    <br>
                        &nbsp;&nbsp;handleClick() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;this.setState(prevState => ({<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isToggleOn: !prevState.isToggleOn<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;}));<br>
                        &nbsp;&nbsp;}<br>
                    <br>
                        &nbsp;&nbsp;render() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return (<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button onClick={this.handleClick}&gt;<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{this.state.isToggleOn ? 'ON' : 'OFF'}<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/button&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;);<br>
                        &nbsp;&nbsp;}<br>
                    }
                </code>
                <p>
                    You have to be careful about the meaning of <code class="inline-code">this</code> in JSX callbacks. In JavaScript, 
                    class methods are not bound by default. If you forget to bind <code class="inline-code">this.handleClick</code> and 
                    pass it to <code class="inline-code">onClick</code>, <code class="inline-code">this</code> will be 
                    <code class="inline-code">undefined</code> when the function is actually called.
                </p>
                <p>
                    This is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, if you refer to a 
                    method without <code class="inline-code">()</code> after it, such as 
                    <code class="inline-code">onClick={this.handleClick}</code>, you should bind that method.
                </p>
                <p>
                    If calling <code class="inline-code">bind</code> annoys you, there are two ways you can get around this. You can use 
                    public class fields syntax to correctly bind callbacks:
                </p>
                <code>
                    class LoggingButton extends React.Component {<br>
                        &nbsp;&nbsp;// This syntax ensures `this` is bound within handleClick.<br>
                        &nbsp;&nbsp;handleClick = () => {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;console.log('this is:', this);<br>
                        &nbsp;&nbsp;};<br>
                        &nbsp;&nbsp;render() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return (<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&gt; onClick={this.handleClick}><br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Click me<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/button&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;);<br>
                        &nbsp;&nbsp;}<br>
                    }
                </code>
                <p>This syntax is enabled by default in Create React App.</p>
                <p>If you aren’t using class fields syntax, you can use an arrow function in the callback:</p>
                <code>
                    class LoggingButton extends React.Component {<br>
                        &nbsp;&nbsp;handleClick() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;console.log('this is:', this);<br>
                        &nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;render() {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;// This syntax ensures `this` is bound within handleClick<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return (<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;button&gt; onClick={() => this.handleClick()}><br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Click me<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/button&gt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;);<br>
                        &nbsp;&nbsp;}<br>
                    }
                </code>
                <p>
                    The problem with this syntax is that a different callback is created each time the
                    <code class="inline-code">LoggingButton</code> renders. In most cases, this is fine. However, if this callback is
                    passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend
                    binding in the constructor or using the class fields syntax, to avoid this sort of performance problem.
                </p>
                <hr>
                
                <h3>Passing Arguments to Event Handlers</h3>
                <p>
                    Inside a loop, it is common to want to pass an extra parameter to an event handler. For example, if
                    <code class="inline-code">id</code> is the row ID, either of the following would work:
                </p>
                <code>
                    &lt;button onClick={(e) => this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;<br>
                    &lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;<br>
                </code>
                <p>
                    The above two lines are equivalent, and use arrow functions and 
                    <code class="inline-code">Function.prototype.bind</code> respectively.
                </p>
                <p>
                    In both cases, the <code class="inline-code">e</code> argument representing the React event will be passed as a 
                    second argument after the ID. With an arrow function, we have to pass it explicitly, but with 
                    <code class="inline-code">bind</code> any further arguments are automatically forwarded.
                </p>
            </section>
            <hr class="rule-after-section">

            <section id="reference" class="main-section">
                <header><h1>Reference</h1></header>
                <p>
                    All the documentation in this page is taken from <a href="https://reactjs.org/" target="_blank">
                    React-js.org</a>. To see the source & full documentation 
                    <a href="https://reactjs.org/docs/hello-world.html" target="_blank">visit here</a>.
                </p>
            </section>
        </main>
    </body>
</html>